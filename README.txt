Функционал проекта: Создание Api сервиса, который предоставляет возможность создавать “сенсоры”,  внедрять измерения “сенсоров”, получать сенсоры при помощи обмена данными в виде JSON.

На что стоит обратить внимание (лично для себя):

## JSON, JACKSON, RESPONSE_ENTITY, HTTP_ENTITY:

Все JSON принимаются и отправляются при помощи объектами классов ResponseEntity<(Здесь указывается класс, который будет телом нашего запроса)> и HttpEntity<(то же самое)> .
При отправке мы используем объект HttpEntity, чтобы по итогу, при помощи RestTemplate, отправить его на сервер в виде json.
Если нам нужно дать короткий ответ, который получит клиент, то мы используем объект типа ResponseEntity.
JACKSON - это библиотека, которая помогает переводить объекты в JSON и наоборот.

# База данных и DTO

Самое интересное - это DTO.
Объект DTO является прослойкой между БД и JSON. Объект DTO является той же копией модели, но только без тех полей, которые приходят пользователю ответом (например id).
Но работа с DTO происходит только для обработки json, он никак не связан с БД, чтобы продолжить работу с БД необходимо конвертировать из DTO-объект в обычный объект.
Для этого используется класс ModelMapper (конвертация обычно происходит в сервисе или сразу в контроллере)

Обработка ошибок

Все ошибки, которые по итогу выбрасываются в контроллер, будут схвачены методом с аннотацией @ExceptionHandler.
Я создал исключение MeasurementException, которое будет ловится этим методом, а ответ решил сделать в виде объекта ResponseEntity, который в теле имеет созданный мной класс MeasurementErrorResponse.

Давайте рассмотрим все случаи, когда ошибки может случится и рассмотрим, как она дойдет на нашего хэндлера:

1) Объект не будет является валидным (это можно определить исходя из аннотаций, которые стоят надо полями моделей) и ошибки валидности попадут в bindingresult.
2) Объекта не существует или пытаемся создать уже существующих объект. В таком случае стоит поступить так: Конвертируем DTO объект в обычный и проверяем его валидатором.

Валидатор сложит все ошибки в наш bindingresult.
Все ошибки, которые были отмечены выше, в итоге попадут в bindingResult, который в случае, если ошибки есть, вызовет методом с выбрасыванием исключения
